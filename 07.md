[ Confidence ](06.html) | [Top](index.html) | 

# Manifesto-Driven #  

## Individuals ##

To me, software development is all about people. Frankly, everything of interest is probably about people, although I’ve spent much of my life learning the ins and outs, the details, the bits and bytes of software.  My main concern in describing how to do software development is to describe an approach that is good for the people.

Frankly, I prioritize being good for the people ahead of being good for the company. Now, I believe that an approach that’s good for the people is best for the company, but even if it weren’t, I’d prioritize the people. People are more important to me than companies.  

## team-driven ##

Scrum and most other so-called “Agile” methods, and the methods before them, have focused on roles, responsibilities, authority, and the like. Then they describe teams in terms of those notions.

Let’s turn that upside down and inside out. Let’s think about a team of people who have come together to do something.  

## software, a thing, a service, ... ##

Agile Software Development is about developing software. The Manifesto refers to “working software” several times, and in what we call the Increment, that notion is central to this book. An Agile Software Development Team has as its core purpose the creation of software.

Now as soon as we say that, we have to reach beyond “creation of software” as the purpose. The software is there to solve a problem, or to support users in carrying out some other purpose. The software may be embedded in some kind of device, such as a heart pacemaker, or a vehicle, or a phone or wristwatch.

The team may not produce software at all. It might provide a service, such as answering questions for taxpayers, or representing people or companies in court. The team might produce food, such as fresh vegetables or savory pizza. 

As we go forward, we’ll consider many kinds of teams, with many kinds of purposes and many kinds of deliverables. Because we’re writing about software development, and because we’re steeped in Agile Software Development, we’ll focus on the software deliverable and generalize from it from time to time.  

## Interactions ##

The Manifesto would have us value “individuals and interactions” over processes and tools. It is this value that brings us to the notion of a team. We want to focus on the people—the individuals—in the team. We want to consider their specific skills, specialties, roles, and responsibilities. 

But the notion of the Team comes from looking at what individuals we need to produce our product, what skills they need, what they’ll be asked to do, and what they need to do it. At the core of that is interactions.

The team members will primarily interact within the team, as they work to decide what to do and how to do it, and as they do the work necessary to create the product. For efficiency and effectiveness, we want the bulk of the interactions to be inside the team. Those interactions are most accessible, most available, most immediate.

The team will also have interactions outside the team. There are various stakeholders: customers, suppliers, other teams, other corporate entities. Perhaps even managers. To the extent possible, we would like those interactions to be more rare than the day-to-day working interactions. We would like those interactions to be driven by the team as much as possible, to avoid distractions and disruption of the work. We’d prefer scheduled outside interactions to unscheduled, and infrequent to frequent.

These are the considerations that drive “Agile” methods to recommend—or demand—cross-functional teams. The notion is simple: if the team is going to need a lot of some specific kind of interaction, then that kind of thing should be inside the team, embodied in one or more individuals. 

Sometimes this is really obvious: if the purpose of the team is to build software, then it needs to have programmers on the team. Otherwise, it’s not a builder of software, but instead a procurer of software. Those are entirely different notions.

Sometimes it’s not quite so obvious, though it should be. If the software product needs to be tested—and it does—then the team needs to include testing skills. If testing were to be done outside the team, the burden of interacting with the testing agency would be too heavy. (It would also reduce the team’s feeling of responsibility for quality. That would be bad.)

Other interactions are less frequent, and less central to the production of the product. Most teams need tax advice or legal advice only infrequently. While it might be useful for team members to know a bit about those topics, it like makes sense to take their tax or legal concerns to outside experts: to procure those services rather than perform them inside the team.

We may turn our attention, later, to specific topics of tax teams, legal teams, and how product teams interact with them. We may also consider teams of technical specialists, such as database experts, architects, manufacturing engineers, and so on. In all those cases, however, our focus will be on understanding the “product” that those specialist teams produce, and on how other teams should best interact with them.

In particular, we’ll want our teams organized so that no other team delays them, gets in their way, checks their work, or drives them via frequent interactions. It may not be possible to do a perfect job of organizing that way, but our focus will always be on allowing our product teams to work effectively, maximizing interactions among the individuals inside the team, and minimizing the impact of outside interaction.  

## Cohesion and Coupling ##

Curiously, the software notions of Cohesion and Coupling mirror the notion of individuals and interactions quite closely. We design software such that its modules, objects, and functions interact primarily locally and only rarely globally. We try to maximize cohesion—the in-team interactions—and minimize the coupling interactions with other teams.

And these notions themselves mirror our observations of systems in the world. Everything seems to be made up of cohesive systems that interact actively within themselves and that connect on a bit less frequent basis with other systems.

We’ll leave that here, and won’t address the question of whether that notion describes reality, or simply our understanding of reality. We’re here to talk about software development.  

## roles ##

Often, methods are defined in terms of Roles. This is a bit of a problem, because people often associate specific roles with specific individuals, and this seems often to lead to hierarchies of control and to territorial disputes. We’d like to avoid disputes entirely, and to minimize hierarchies of control as part of our desire to minimize interactions outside the team. 

That’s not to say that we’re opposed to control. Not at all: control, especially in the form of feedback, is essential to high-functioning teams. But we want to avoid the hierarchy. To the degree possible, we don’t want to bestow authority on specific individuals. We want authority and responsibility to exist at the team level.  

## Accountability ##

“There's no word for accountability in Finnish. Accountability is something that is left when responsibility has been subtracted.” --Pasi Sahlberg  

## responsibilities ##  

## authority ##  

## purpose ##  

## autonomy ##  

## mastery ##  

## skills ##  

## specialties ##  

## t-shaped paint-dripped ##


[ Confidence ](06.html) | [Top](index.html) | 


<!--ignore-->


