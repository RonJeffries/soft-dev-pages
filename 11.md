[Confidence](10.html) | [Top](index.html) | 

## Architecture and Design ##  

Generally, in this book, we’ll be using the word “design” to refer to software design, not user interface design. We’re referring to the “software architecture”, the objects and classes that make up the system, or the system of functions, or the micro services. Whatever the programming paradigm, we always have the issue of what the pieces are and how they fit together.

That’s what we mean by design.  

Clearly we want the “right” architecture and design for our system. We want a design that fits what we’re building. It should be neither too big nor too small. We’re usually more concerned about not having enough design, and I think that’s a good concern. If we don’t invest enough in design, our work becomes more difficult, the system itself often slows down, and almost always, a deficit in design results in defects in the code.

It’s also possible to invest too much in architecture and design. More than one effort has been cancelled as a failure because the team was doing a great job creating infrastructure, but the business people became impatient because the team didn’t seem to be creating a solution to the business problem.

We need just enough design, neither too much nor too little. That’s easy to say, and not so easy to do. The truth is, we need to continually wander between having a little more design than we need, and a little less.   

When I took my degree in Computer and Communication Science, it was understood that first you design the program, and then you write it. Of course, when we set out to do that, bad things always happened. 

One bad thing was that it took too long to get the program done. In class, that meant we sometimes submitted a design but not much code. At work it meant that the boss would get impatient because whatever we were supposed to be producing wasn’t there yet.

And then, if we did finally get the program, the design never seemed to work quite as well as we had hoped it would. We were sure that this great design would make the program easy to write, and sometimes it did, for a while. But as time went on, the design seemed not to be good enough.

Our reaction, often, was to say “we should have done more design”, meaning that we should have done more design before writing the program. 

The truth, I now believe, is that we did need to do more design, and we didn’t need to do it before writing the program, but as we wrote the program. We need to design all the time.  

No matter how much we design, or when we do it, we always seem to find that the design doesn’t quite help us as much it should. It would be easy to blame ourselves for this, and even easier to blame some prior designers. But it seems to happen more often than not. I don’t recall ever seeing a system where the design wound up being just what we needed as time went on. So my belief is that it’s a property of growing systems. The design of a growing system will go out of date and deviate from the design we wish we had.

The question is what to do about it.  

  

  

  

  

  

  

  

  




[Confidence](10.html) | [Top](index.html) | 


<!--ignore-->


